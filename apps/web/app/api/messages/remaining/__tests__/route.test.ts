/**
 * Unit tests for apps/web/app/api/messages/remaining/route.ts
 * Generated by TDD Enforcer - Basic tests to satisfy coverage requirements
 */

import { NextRequest } from 'next/server';
import { GET } from '../route';
import { currentUser } from '@clerk/nextjs/server';

const mockCurrentUser = currentUser as jest.MockedFunction<typeof currentUser>;

// Mock NextRequest for testing
const mockRequest = new NextRequest('http://localhost:3000/api/messages/remaining', {
    method: 'GET',
});

describe('GET /api/messages/remaining', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('should return credit info for authenticated user', async () => {
        // Arrange
        const mockUser = { id: 'user123' };
        mockCurrentUser.mockResolvedValue(mockUser as any);

        // Act
        const response = await GET(mockRequest);
        const data = await response.json();

        // Assert
        expect(response.status).toBe(200);
        expect(data).toHaveProperty('remaining', 100);
        expect(data).toHaveProperty('limit', 100);
        expect(data).toHaveProperty('resetDate');
        expect(data).toHaveProperty('isUnlimited', true);
        expect(new Date(data.resetDate)).toBeInstanceOf(Date);
    });

    it('should return credit info for unauthenticated user', async () => {
        // Arrange
        mockCurrentUser.mockResolvedValue(null);

        // Act
        const response = await GET(mockRequest);
        const data = await response.json();

        // Assert
        expect(response.status).toBe(200);
        expect(data).toHaveProperty('remaining', 100);
        expect(data).toHaveProperty('limit', 100);
        expect(data).toHaveProperty('resetDate');
        expect(data).toHaveProperty('isUnlimited', false);
        expect(new Date(data.resetDate)).toBeInstanceOf(Date);
    });

    it('should handle errors gracefully', async () => {
        // Arrange
        mockCurrentUser.mockRejectedValue(new Error('Auth service unavailable'));

        // Act
        const response = await GET(mockRequest);
        const data = await response.json();

        // Assert
        expect(response.status).toBe(500);
        expect(data).toHaveProperty('error', 'Failed to fetch credit information');
    });

    it('should have correct reset date format', async () => {
        // Arrange
        mockCurrentUser.mockResolvedValue({ id: 'user123' } as any);

        // Act
        const response = await GET(mockRequest);
        const data = await response.json();

        // Assert
        expect(data.resetDate).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/);

        // Verify reset date is approximately 24 hours from now
        const resetDate = new Date(data.resetDate);
        const now = new Date();
        const diffHours = (resetDate.getTime() - now.getTime()) / (1000 * 60 * 60);
        expect(diffHours).toBeGreaterThan(23);
        expect(diffHours).toBeLessThan(25);
    });
});
